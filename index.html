<!DOCTYPE html>
<html>
<head>
</head>
<body>
<style>
	* { margin:0; padding:0;}
	body {background-color:#111322} 

</style>
<div id="posos" height="100%" width="100%" style="">
	<canvas id="Canvas" height="100%" width="100%" style="position: fixed; display:block; z-index: 0; ">:c</canvas>
	<canvas id="Canvas2" height="100%" width="100%" style="position: fixed; display:block; z-index: 1;"></canvas>
</div>
<audio id="dolbit" src="http://streamcluster02.true.nl:8000/qdance-hard" autoplay=1></audio>
<script>
var l=document.getElementById;

var x=[],y=[],dx=[0],dy=[0],d=[0];

function add(xx,yy)
{
	x.push(xx);
	y.push(yy);
	dx.push((Math.random()-0.5)/2);
	dy.push((Math.random()-0.5)/2);
	d.push(Math.random()*3+0.1);
}
var len=200;

var par={x:0,y:0,n:{x:0,y:0}};
function draw()
{
	var c = document.getElementById("Canvas");
	var ctx = c.getContext("2d");
	var l=x.length;
	ctx.clearRect(0,0,c.width,c.height);
//	ctx.fillStyle="#444466";
//	ctx.fillRect(0,0,c.width,c.height);
	ctx.translate(par.x,par.y);
	ctx.fillStyle="#9999bb";
	for(var i=1;i<l;i++)
	{
		if(x[i]<-len)
			x[i]=c.width+len;
		else if(x[i]>(c.width+len))
			x[i]=-len;
		if(y[i]<-len)
			y[i]=c.height+len;
		else if(y[i]>(c.height+len))
			y[i]=-len;
	}
	for(var i=0;i<l;i++)
	{
		x[i]+=dx[i];
		y[i]+=dy[i];
		ctx.globalAlpha=1;
		ctx.beginPath();
		ctx.arc(x[i],y[i],d[i],0,2*Math.PI);
		ctx.fill();
		for(var j=i+1;j<l;j++)
		{
			var dis=Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));
			if(dis<len)
			{
				ctx.strokeStyle="#9999bb";
				//ctx.globalAlpha=(len-dis)/len;
				ctx.lineWidth=(len-dis)/len;
				ctx.beginPath()
				ctx.moveTo(x[i],y[i]);
				ctx.lineTo(x[j],y[j]);
				ctx.stroke();
			}
		}
	}
	ctx.translate(-par.x,-par.y);
}
var height;
var width;
function resize()
{
	var ss=document.getElementById("Canvas2");
	var c = document.getElementById("Canvas");
	c.width=window.innerWidth;
	c.height=window.innerHeight;
	ss.width=window.innerWidth;
	ss.height=window.innerHeight;
	height=c.height;
	width=c.width;
}
resize();
window.addEventListener('resize',resize,false);

for(var i=0;i<100;i++)
{
	add(Math.random()*(width+2*len)-len,Math.random()*(height+2*len)-len);
}

window.onmousemove=function(e)
{
	x[0] = e.offsetX;
	y[0] = e.offsetY;

	par.n.x=(x[0]-width/2)/30;
	par.n.y=(y[0]-height/2)/30;

	par.x+=(par.n.x-par.x)*0.01;
	par.y+=(par.n.y-par.y)*0.01;

	x[0]-=par.x;
	y[0]-=par.y;
}

window.onclick=function(e)
{
	var cnt=4+(Math.random()>0.5);
	for(var i=1;i<cnt;i++)
		add(x[0],y[0]);
}/**/

setInterval(function(){draw(); draw2();},20);
</script>
<script>
var c2 = document.getElementById("Canvas2");
var ctx2=c2.getContext("2d");

var sos=document.getElementsByClassName("sos");


var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
var analyser = audioCtx.createAnalyser();

var stream=document.getElementById("dolbit");

stream.crossOrigin = "anonymous";

source = audioCtx.createMediaElementSource(stream);
source.connect(analyser);
analyser.connect(audioCtx.destination);

analyser.fftSize = 2048;
var bufferLength = analyser.frequencyBinCount;
var dataArray = new Uint8Array(bufferLength);

var draw2 = function ()
{
	var c = document.getElementById("Canvas2");
	var ctx = c.getContext("2d");

	analyser.getByteTimeDomainData(dataArray);

	ctx.clearRect(0,0,c.width,c.height);

	ctx.beginPath()
	ctx.strokeStyle="#ffffff";
	ctx.moveTo(0,c.height/2);

	for(var i=0;i<bufferLength; i++)
	{
		ctx.lineTo(i/bufferLength*c.width,((dataArray[i]/128-1)*10+1)*(c.height/2));
	}
	ctx.stroke();

}

/*
var SoundCloudAudioSource = function(audioElement) {
    var player = document.getElementById(audioElement);
    var self = this;
    var analyser;
    var audioCtx = new (window.AudioContext || window.webkitAudioContext); // this is because it's not been standardised accross browsers yet.
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256; // see - there is that 'fft' thing. 
    var source = audioCtx.createMediaElementSource(player); // this is where we hook up the <audio> element
    source.connect(analyser);
    analyser.connect(audioCtx.destination);
    var sampleAudioStream = function() {
        // This closure is where the magic happens. Because it gets called with setInterval below, it continuously samples the audio data
        // and updates the streamData and volume properties. This the SoundCouldAudioSource function can be passed to a visualization routine and 
        // continue to give real-time data on the audio stream.
        analyser.getByteFrequencyData(self.streamData);
        // calculate an overall volume value
        var total = 0;
        for (var i = 0; i < 80; i++) { // get the volume from the first 80 bins, else it gets too loud with treble
            total += self.streamData[i];
        }
        self.volume = total;
    };
    setInterval(sampleAudioStream, 20); // 
    // public properties and methods
    this.volume = 0;
    this.streamData = new Uint8Array(128); // This just means we will have 128 "bins" (always half the analyzer.fftsize value), each containing a number between 0 and 255. 
    this.playStream = function(streamUrl) {
        // get the input stream from the audio element
        player.setAttribute('src', streamUrl);
        player.play();
    }
};
*/

</script>
<div class="sos" id="keks"></div>
</body>
</html>

